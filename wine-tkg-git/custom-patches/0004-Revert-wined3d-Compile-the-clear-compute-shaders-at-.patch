From c8cc854d8853a22c28614344fca1760af65fc8ce Mon Sep 17 00:00:00 2001
From: James McDonnell <topgamer7@gmail.com>
Date: Mon, 29 Jul 2024 18:19:33 -0700
Subject: [PATCH 04/29] Revert "wined3d: Compile the clear compute shaders at
 runtime."

This reverts commit c319b874669450cc17ebe9a7f459a17b86cdcddb.
---
 dlls/wined3d/Makefile.in                      |   1 -
 .../cs_uav_clear_1d_array_float_code.hlsl     |  33 --
 .../cs_uav_clear_1d_array_uint_code.hlsl      |  33 --
 dlls/wined3d/cs_uav_clear_1d_float_code.hlsl  |  33 --
 dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl   |  33 --
 .../cs_uav_clear_2d_array_float_code.hlsl     |  33 --
 .../cs_uav_clear_2d_array_uint_code.hlsl      |  33 --
 dlls/wined3d/cs_uav_clear_2d_float_code.hlsl  |  33 --
 dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl   |  33 --
 dlls/wined3d/cs_uav_clear_3d_float_code.hlsl  |  33 --
 dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl   |  33 --
 .../cs_uav_clear_buffer_float_code.hlsl       |  33 --
 .../cs_uav_clear_buffer_uint_code.hlsl        |  33 --
 dlls/wined3d/resource.rc                      |  30 --
 dlls/wined3d/view.c                           | 111 +----
 dlls/wined3d/wined3d_shaders.h                | 388 ++++++++++++++++++
 16 files changed, 406 insertions(+), 520 deletions(-)
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_3d_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl
 delete mode 100644 dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl
 delete mode 100644 dlls/wined3d/resource.rc
 create mode 100644 dlls/wined3d/wined3d_shaders.h

diff --git a/dlls/wined3d/Makefile.in b/dlls/wined3d/Makefile.in
index 69415ebb7f9..634cd903799 100644
--- a/dlls/wined3d/Makefile.in
+++ b/dlls/wined3d/Makefile.in
@@ -19,7 +19,6 @@ SOURCES = \
 	palette.c \
 	query.c \
 	resource.c \
-	resource.rc \
 	sampler.c \
 	shader.c \
 	shader_sm1.c \
diff --git a/dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl
deleted file mode 100644
index 9b933321d1d..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_array_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1DArray<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl
deleted file mode 100644
index 7b51aefe034..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_array_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1DArray<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_1d_float_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_float_code.hlsl
deleted file mode 100644
index dbf37e565ad..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1D<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl
deleted file mode 100644
index fb842339e9b..00000000000
--- a/dlls/wined3d/cs_uav_clear_1d_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture1D<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(64, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl
deleted file mode 100644
index c356a6ed64b..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_array_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2DArray<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl
deleted file mode 100644
index 09fb97c19a9..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_array_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2DArray<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_float_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_float_code.hlsl
deleted file mode 100644
index f74b694eee4..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2D<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl
deleted file mode 100644
index cd0f73e92d5..00000000000
--- a/dlls/wined3d/cs_uav_clear_2d_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture2D<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_3d_float_code.hlsl b/dlls/wined3d/cs_uav_clear_3d_float_code.hlsl
deleted file mode 100644
index 63e049230c8..00000000000
--- a/dlls/wined3d/cs_uav_clear_3d_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture3D<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl
deleted file mode 100644
index 6abff9b8fb7..00000000000
--- a/dlls/wined3d/cs_uav_clear_3d_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWTexture3D<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(8, 8, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (all(thread_id.xy < u_info.dst_extent.xy))
-        dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl b/dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl
deleted file mode 100644
index 3710948b318..00000000000
--- a/dlls/wined3d/cs_uav_clear_buffer_float_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWBuffer<float4> dst;
-
-struct
-{
-    float4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(128, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl b/dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl
deleted file mode 100644
index 64bf3c63b09..00000000000
--- a/dlls/wined3d/cs_uav_clear_buffer_uint_code.hlsl
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2019 Philip Rebohle
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-RWBuffer<uint4> dst;
-
-struct
-{
-    uint4 clear_value;
-    int2 dst_offset;
-    int2 dst_extent;
-} u_info;
-
-[numthreads(128, 1, 1)]
-void main(int3 thread_id : SV_DispatchThreadID)
-{
-    if (thread_id.x < u_info.dst_extent.x)
-        dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
-}
diff --git a/dlls/wined3d/resource.rc b/dlls/wined3d/resource.rc
deleted file mode 100644
index a970c3eecbc..00000000000
--- a/dlls/wined3d/resource.rc
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2024 Giovanni Mascellani for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-cs_uav_clear_buffer_float_code.hlsl RCDATA cs_uav_clear_buffer_float_code.hlsl
-cs_uav_clear_buffer_uint_code.hlsl RCDATA cs_uav_clear_buffer_uint_code.hlsl
-cs_uav_clear_1d_array_float_code.hlsl RCDATA cs_uav_clear_1d_array_float_code.hlsl
-cs_uav_clear_1d_array_uint_code.hlsl RCDATA cs_uav_clear_1d_array_uint_code.hlsl
-cs_uav_clear_1d_float_code.hlsl RCDATA cs_uav_clear_1d_float_code.hlsl
-cs_uav_clear_1d_uint_code.hlsl RCDATA cs_uav_clear_1d_uint_code.hlsl
-cs_uav_clear_2d_array_float_code.hlsl RCDATA cs_uav_clear_2d_array_float_code.hlsl
-cs_uav_clear_2d_array_uint_code.hlsl RCDATA cs_uav_clear_2d_array_uint_code.hlsl
-cs_uav_clear_2d_float_code.hlsl RCDATA cs_uav_clear_2d_float_code.hlsl
-cs_uav_clear_2d_uint_code.hlsl RCDATA cs_uav_clear_2d_uint_code.hlsl
-cs_uav_clear_3d_float_code.hlsl RCDATA cs_uav_clear_3d_float_code.hlsl
-cs_uav_clear_3d_uint_code.hlsl RCDATA cs_uav_clear_3d_uint_code.hlsl
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
index 91b88c2037d..ca97f6258eb 100644
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -18,6 +18,7 @@
  */
 
 #include "wined3d_private.h"
+#include "wined3d_shaders.h"
 #include "wined3d_gl.h"
 #include "wined3d_vk.h"
 
@@ -1887,36 +1888,6 @@ HRESULT wined3d_unordered_access_view_gl_init(struct wined3d_unordered_access_vi
     return hr;
 }
 
-static int compile_hlsl_cs(const struct vkd3d_shader_code *hlsl, struct vkd3d_shader_code *dxbc)
-{
-    struct vkd3d_shader_hlsl_source_info hlsl_info;
-    struct vkd3d_shader_compile_info info;
-
-    static const struct vkd3d_shader_compile_option options[] =
-    {
-        {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_12},
-    };
-
-    info.type = VKD3D_SHADER_STRUCTURE_TYPE_COMPILE_INFO;
-    info.next = &hlsl_info;
-    info.source = *hlsl;
-    info.source_type = VKD3D_SHADER_SOURCE_HLSL;
-    info.target_type = VKD3D_SHADER_TARGET_DXBC_TPF;
-    info.options = options;
-    info.option_count = ARRAY_SIZE(options);
-    info.log_level = VKD3D_SHADER_LOG_NONE;
-    info.source_name = NULL;
-
-    hlsl_info.type = VKD3D_SHADER_STRUCTURE_TYPE_HLSL_SOURCE_INFO;
-    hlsl_info.next = NULL;
-    hlsl_info.entry_point = "main";
-    hlsl_info.secondary_code.code = NULL;
-    hlsl_info.secondary_code.size = 0;
-    hlsl_info.profile = "cs_5_0";
-
-    return vkd3d_shader_compile(&info, dxbc, NULL);
-}
-
 struct wined3d_uav_clear_constants_vk
 {
     VkClearColorValue color;
@@ -1925,80 +1896,32 @@ struct wined3d_uav_clear_constants_vk
 };
 
 static VkPipeline create_uav_pipeline(struct wined3d_context_vk *context_vk,
-        struct wined3d_pipeline_layout_vk *layout, const char *resource_filename,
+        struct wined3d_pipeline_layout_vk *layout, const unsigned int *byte_code, size_t byte_code_size,
         enum wined3d_shader_resource_type resource_type)
 {
     VkComputePipelineCreateInfo pipeline_info;
     struct wined3d_shader_desc shader_desc;
     const struct wined3d_vk_info *vk_info;
-    struct vkd3d_shader_code code, dxbc;
     struct wined3d_context *context;
     VkShaderModule shader_module;
     VkDevice vk_device;
-    void *resource_ptr;
     VkPipeline result;
-    HGLOBAL global;
-    HMODULE module;
-    HRSRC resource;
     VkResult vr;
-    int ret;
 
     vk_info = context_vk->vk_info;
     context = &context_vk->c;
 
-    if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
-                           (const char *)create_uav_pipeline, &module))
-    {
-        ERR("Failed to get a reference to the current module, last error %ld.\n", GetLastError());
-        return VK_NULL_HANDLE;
-    }
-
-    if (!(resource = FindResourceA(module, resource_filename, (const char *)RT_RCDATA)))
-    {
-        ERR("Failed to retrieve resource, last error %ld.\n", GetLastError());
-        return VK_NULL_HANDLE;
-    }
-
-    if (!(global = LoadResource(module, resource)))
-    {
-        ERR("Failed to load resource, last error %ld.\n", GetLastError());
-        return VK_NULL_HANDLE;
-    }
-
-    if (!(resource_ptr = LockResource(global)))
-    {
-        ERR("Failed to lock resource.\n");
-        FreeResource(resource);
-        return VK_NULL_HANDLE;
-    }
-
-    code.code = resource_ptr;
-    code.size = SizeofResource(module, resource);
-
-    if ((ret = compile_hlsl_cs(&code, &dxbc)) < 0)
-    {
-        ERR("Failed to compile shader, ret %d.\n", ret);
-        FreeResource(resource);
-        return VK_NULL_HANDLE;
-    }
-
-    if (FreeResource(resource))
-        ERR("Failed to free resource.\n");
-
-    shader_desc.byte_code = dxbc.code;
-    shader_desc.byte_code_size = dxbc.size;
+    shader_desc.byte_code = (const DWORD *)byte_code;
+    shader_desc.byte_code_size = byte_code_size;
 
     shader_module = (VkShaderModule)context->device->adapter->shader_backend->shader_compile(context, &shader_desc,
             WINED3D_SHADER_TYPE_COMPUTE);
     if (shader_module == VK_NULL_HANDLE)
     {
         ERR("Failed to create shader.\n");
-        vkd3d_shader_free_shader_code(&dxbc);
         return VK_NULL_HANDLE;
     }
 
-    vkd3d_shader_free_shader_code(&dxbc);
-
     pipeline_info.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
     pipeline_info.pNext = NULL;
     pipeline_info.flags = 0;
@@ -2048,30 +1971,32 @@ void wined3d_device_vk_uav_clear_state_init(struct wined3d_device_vk *device_vk)
     vk_set_bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
     state->buffer_layout = wined3d_context_vk_get_pipeline_layout(context_vk, vk_set_bindings, 2);
 
+#define SHADER_DESC(name) name, sizeof(name)
     state->float_pipelines.buffer = create_uav_pipeline(context_vk, state->buffer_layout,
-            "cs_uav_clear_buffer_float_code.hlsl", WINED3D_SHADER_RESOURCE_BUFFER);
+            SHADER_DESC(cs_uav_clear_buffer_float_code), WINED3D_SHADER_RESOURCE_BUFFER);
     state->uint_pipelines.buffer = create_uav_pipeline(context_vk, state->buffer_layout,
-            "cs_uav_clear_buffer_uint_code.hlsl", WINED3D_SHADER_RESOURCE_BUFFER);
+            SHADER_DESC(cs_uav_clear_buffer_uint_code), WINED3D_SHADER_RESOURCE_BUFFER);
     state->float_pipelines.image_1d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1D);
+            SHADER_DESC(cs_uav_clear_1d_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_1D);
     state->uint_pipelines.image_1d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1D);
+            SHADER_DESC(cs_uav_clear_1d_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_1D);
     state->float_pipelines.image_1d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_array_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
+            SHADER_DESC(cs_uav_clear_1d_array_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
     state->uint_pipelines.image_1d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_1d_array_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
+            SHADER_DESC(cs_uav_clear_1d_array_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY);
     state->float_pipelines.image_2d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2D);
+            SHADER_DESC(cs_uav_clear_2d_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_2D);
     state->uint_pipelines.image_2d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2D);
+            SHADER_DESC(cs_uav_clear_2d_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_2D);
     state->float_pipelines.image_2d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_array_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
+            SHADER_DESC(cs_uav_clear_2d_array_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
     state->uint_pipelines.image_2d_array = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_2d_array_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
+            SHADER_DESC(cs_uav_clear_2d_array_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY);
     state->float_pipelines.image_3d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_3d_float_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_3D);
+            SHADER_DESC(cs_uav_clear_3d_float_code), WINED3D_SHADER_RESOURCE_TEXTURE_3D);
     state->uint_pipelines.image_3d = create_uav_pipeline(context_vk, state->image_layout,
-            "cs_uav_clear_3d_uint_code.hlsl", WINED3D_SHADER_RESOURCE_TEXTURE_3D);
+            SHADER_DESC(cs_uav_clear_3d_uint_code), WINED3D_SHADER_RESOURCE_TEXTURE_3D);
+#undef SHADER_DESC
 
     state->buffer_group_size.x = 128;
     state->buffer_group_size.y = 1;
diff --git a/dlls/wined3d/wined3d_shaders.h b/dlls/wined3d/wined3d_shaders.h
new file mode 100644
index 00000000000..db763290af9
--- /dev/null
+++ b/dlls/wined3d/wined3d_shaders.h
@@ -0,0 +1,388 @@
+/*
+ * Copyright 2019 Philip Rebohle
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINED3D_SHADERS_H
+#define __WINE_WINED3D_SHADERS_H
+
+static const uint32_t cs_uav_clear_buffer_float_code[] =
+{
+#if 0
+    RWBuffer<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(128, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0xe114ba61, 0xff6a0d0b, 0x7b25c8f4, 0xfcf7cf22, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400089c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000080, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_buffer_uint_code[] =
+{
+#if 0
+    RWBuffer<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(128, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x3afd0cfd, 0x5145c166, 0x5b9f76b8, 0xa73775cd, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400089c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000080, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_array_float_code[] =
+{
+#if 0
+    RWTexture1DArray<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x3d73bc2d, 0x2b635f3d, 0x6bf98e92, 0xbe0aa5d9, 0x00000001, 0x0000011c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000c8, 0x00050050, 0x00000032, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400389c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x04000036, 0x001000e2, 0x00000000, 0x00020556, 0x080000a4, 0x0011e0f2, 0x00000000,
+    0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_array_uint_code[] =
+{
+#if 0
+    RWTexture1DArray<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[int2(u_info.dst_offset.x + thread_id.x, thread_id.y)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x2f0ca457, 0x72068b34, 0xd9dadc2b, 0xd3178c3e, 0x00000001, 0x0000011c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000c8, 0x00050050, 0x00000032, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400389c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x04000036, 0x001000e2, 0x00000000, 0x00020556, 0x080000a4, 0x0011e0f2, 0x00000000,
+    0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_float_code[] =
+{
+#if 0
+    RWTexture1D<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x05266503, 0x4b97006f, 0x01a5cc63, 0xe617d0a1, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400109c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_1d_uint_code[] =
+{
+#if 0
+    RWTexture1D<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(64, 1, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (thread_id.x < u_info.dst_extent.x)
+            dst[u_info.dst_offset.x + thread_id.x] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x19d5c8f2, 0x3ca4ac24, 0x9e258499, 0xf0463fd6, 0x00000001, 0x0000010c, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000b8, 0x00050050, 0x0000002e, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400109c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020012, 0x02000068, 0x00000001, 0x0400009b, 0x00000040, 0x00000001, 0x00000001,
+    0x07000022, 0x00100012, 0x00000000, 0x0002000a, 0x0020802a, 0x00000000, 0x00000001, 0x0304001f,
+    0x0010000a, 0x00000000, 0x0700001e, 0x00100012, 0x00000000, 0x0002000a, 0x0020800a, 0x00000000,
+    0x00000001, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100006, 0x00000000, 0x00208e46, 0x00000000,
+    0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_array_float_code[] =
+{
+#if 0
+    RWTexture2DArray<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x924d2d2c, 0xb9166376, 0x99f83871, 0x8ef65025, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400409c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_array_uint_code[] =
+{
+#if 0
+    RWTexture2DArray<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy + thread_id.xy, thread_id.z)] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0xa92219d4, 0xa2c5e47d, 0x0d308500, 0xf32197b4, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400409c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_float_code[] =
+{
+#if 0
+    RWTexture2D<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x6e735b3f, 0x7348c4fa, 0xb3634e42, 0x50e2d99b, 0x00000001, 0x00000128, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000d4, 0x00050050, 0x00000035, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400189c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x001000f2, 0x00000000, 0x00020546, 0x00208546, 0x00000000, 0x00000001,
+    0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000,
+    0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_2d_uint_code[] =
+{
+#if 0
+    RWTexture2D<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[u_info.dst_offset.xy + thread_id.xy] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0xf01db5dd, 0xc7dc5e55, 0xb017c1a8, 0x55abd52d, 0x00000001, 0x00000128, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000d4, 0x00050050, 0x00000035, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400189c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020032, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x001000f2, 0x00000000, 0x00020546, 0x00208546, 0x00000000, 0x00000001,
+    0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46, 0x00000000, 0x00208e46, 0x00000000, 0x00000000,
+    0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_3d_float_code[] =
+{
+#if 0
+    RWTexture3D<float4> dst;
+
+    struct
+    {
+        float4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x5d8f36a0, 0x30fa86a5, 0xfec7f2ef, 0xdfd76cbb, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400289c, 0x0011e000, 0x00000000, 0x00005555,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+static const uint32_t cs_uav_clear_3d_uint_code[] =
+{
+#if 0
+    RWTexture3D<uint4> dst;
+
+    struct
+    {
+        uint4 clear_value;
+        int2 dst_offset;
+        int2 dst_extent;
+    } u_info;
+
+    [numthreads(8, 8, 1)]
+    void main(int3 thread_id : SV_DispatchThreadID)
+    {
+        if (all(thread_id.xy < u_info.dst_extent.xy))
+            dst[int3(u_info.dst_offset.xy, 0) + thread_id.xyz] = u_info.clear_value;
+    }
+#endif
+    0x43425844, 0x5b9c95b1, 0xc9bde4e3, 0x9aaff806, 0x24a1d264, 0x00000001, 0x00000138, 0x00000003,
+    0x0000002c, 0x0000003c, 0x0000004c, 0x4e475349, 0x00000008, 0x00000000, 0x00000008, 0x4e47534f,
+    0x00000008, 0x00000000, 0x00000008, 0x58454853, 0x000000e4, 0x00050050, 0x00000039, 0x0100086a,
+    0x04000059, 0x00208e46, 0x00000000, 0x00000002, 0x0400289c, 0x0011e000, 0x00000000, 0x00004444,
+    0x0200005f, 0x00020072, 0x02000068, 0x00000001, 0x0400009b, 0x00000008, 0x00000008, 0x00000001,
+    0x07000022, 0x00100032, 0x00000000, 0x00020046, 0x00208ae6, 0x00000000, 0x00000001, 0x07000001,
+    0x00100012, 0x00000000, 0x0010001a, 0x00000000, 0x0010000a, 0x00000000, 0x0304001f, 0x0010000a,
+    0x00000000, 0x0700001e, 0x00100032, 0x00000000, 0x00020046, 0x00208046, 0x00000000, 0x00000001,
+    0x04000036, 0x001000c2, 0x00000000, 0x00020aa6, 0x080000a4, 0x0011e0f2, 0x00000000, 0x00100e46,
+    0x00000000, 0x00208e46, 0x00000000, 0x00000000, 0x01000015, 0x0100003e,
+};
+
+#endif
-- 
2.45.2

